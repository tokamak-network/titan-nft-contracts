{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1ERC721BridgeProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../universal/Proxy.sol\";\nimport \"./L1ERC721BridgeStorage.sol\";\n\ncontract L1ERC721BridgeProxy is Proxy, L1ERC721BridgeStorage\n{\n    constructor(address _admin) Proxy(_admin){\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == admin(), \"sender is not admin\"\n        );\n        _;\n    }\n\n    function owner() external virtual returns (address) {\n        return _getAdmin();\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _changeAdmin(newOwner);\n    }\n\n}\n"
    },
    "contracts/L1/L1ERC721BridgeStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract L1ERC721BridgeStorage {\n\n    /**\n     * @notice Messenger contract on this domain. (CrossDomainMessenger)\n     */\n    address public MESSENGER;\n\n    /**\n     * @notice Address of the bridge on the other network.\n     */\n    address public OTHER_BRIDGE;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] public __gap;\n\n    /**\n     * @notice Contract version number (major).\n     */\n    uint256 public MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    uint256 public MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    uint256 public PATCH_VERSION;\n\n}"
    },
    "contracts/L2/L2ERC721BridgeProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../universal/Proxy.sol\";\nimport \"./L2ERC721BridgeStorage.sol\";\n\ncontract L2ERC721BridgeProxy is Proxy, L2ERC721BridgeStorage\n{\n    constructor(address _admin) Proxy(_admin){\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == admin(), \"sender is not admin\"\n        );\n        _;\n    }\n\n    function owner() external virtual returns (address) {\n        return _getAdmin();\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _changeAdmin(newOwner);\n    }\n\n}\n"
    },
    "contracts/L2/L2ERC721BridgeStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract L2ERC721BridgeStorage {\n\n    /**\n     * @notice Messenger contract on this domain. (CrossDomainMessenger)\n     */\n    address public MESSENGER;\n\n    /**\n     * @notice Address of the bridge on the other network.\n     */\n    address public OTHER_BRIDGE;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] public __gap;\n\n    /**\n     * @notice Contract version number (major).\n     */\n    uint256 public MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    uint256 public MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    uint256 public PATCH_VERSION;\n\n    /**\n     * @notice Mapping of L1 token to L2 token to ID to boolean, indicating if the given L1 token\n     *         by ID was deposited for a given L2 token.\n     */\n    mapping(address => mapping(address => mapping(uint256 => bool))) public deposits;\n\n\n}"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract Proxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    // modifier proxyCallIfNotAdmin() {\n    //     if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n    //         _;\n    //     } else {\n    //         // This WILL halt the call frame on completion.\n    //         _doProxyCall();\n    //     }\n    // }\n    modifier onlyAdmin() {\n        require(msg.sender == _getAdmin(), \"not admin\");\n        _;\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) public virtual onlyAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        public\n        payable\n        virtual\n        onlyAdmin\n        returns (bytes memory)\n    {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) public virtual onlyAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    // function admin() public virtual proxyCallIfNotAdmin returns (address) {\n    //     return _getAdmin();\n    // }\n    function admin() public virtual view returns (address) {\n        return _getAdmin();\n    }\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    // function implementation() public virtual proxyCallIfNotAdmin returns (address) {\n    //     return _getImplementation();\n    // }\n    function implementation() public virtual view returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner_;\n        assembly {\n            owner_ := sload(OWNER_KEY)\n        }\n        return owner_;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 625
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}